#10. Securing Apache HBase #
HBase提供了相关的机制保障HBase各个组件和方面，以及它是如何与Hadoop余下的组件、客户端和外部资源相联系的安全性。

## 57.  Web UI使用安全的HTTP（HTTPS）##
对master和region服务器，默认Hbase安装使用不安全的HTTP链接。启动安全的HTTP链接，设置hbase-site.xml中的**hbase.ss1.enabled**为真。这个属性不改变访问Web UI的端口。要改变某个Hbase内容的端口，配置相关端口在hbase-site.xml中。有以下设置：



- hbase.master.info.port
- hbase.regionserver.info.port

## 58. Using SPNEGO for Kerberos authentication with Web UIs##
HBase Web UIs的Kerberos-authentication可以通过配置hbase.security.authentication.ui的SPNEGO属性来打开。这要求HBase同样配置了要使用RPCs的Kerberos-authentication（如，hbase.security.authentication = kerberos）


	<property>
  	 <name>hbase.security.authentication.ui</name>
  	 <value>kerberos</value>
  	 <description>Controls what kind of authentication should be used for the HBase web UIs.</description>
	</property>
	<property>
  	 <name>hbase.security.authentication</name>
  	 <value>kerberos</value>
  	 <description>The Kerberos keytab file to use for SPNEGO authentication by the web server.</description>
	</property>

许多属性为配置web server的SPNEGO认证而存在：

	<property>
	 <name>hbase.security.authentication.spnego.kerberos.principal</name>
 	 <value>HTTP/_HOST@EXAMPLE.COM</value>
  	 <description>Required for SPNEGO, the Kerberos principal to use for SPNEGO authentication by the web server. The _HOST keyword will be automatically substituted with the node's hostname.</description>
	</property>
	<property>
  	 <name>hbase.security.authentication.spnego.kerberos.keytab</name>
  	 <value>/etc/security/keytabs/spnego.service.keytab</value>
  	 <description>Required for SPNEGO, the Kerberos keytab file to use for SPNEGO authentication by the web server.</description>
	</property>
	<property>
  	 <name>hbase.security.authentication.spnego.kerberos.name.rules</name>
  	 <value></value>
  	 <description>Optional, Hadoop-style `auth_to_local` rules which will be parsed and used in the handling of Kerberos principals</description>
	</property>
	<property>
  	 <name>hbase.security.authentication.signature.secret.file</name>
  	 <value></value>
 	 <description>Optional, a file whose contents will be used as a secret to sign the HTTP cookies as a part of the SPNEGO authentication handshake. If this is not provided, Java's `Random` library will be used for the secret.</description>
</property>

## 59. Apache HBase 访问的安全客户端##

0.92之后发不布的版本支持可选的SASL客户端认证。这里介绍如何设置Apache Hbase和客户端 来连接安全的Hbase资源。

### 59.1 先决条件 ###
**Hadoop认证配置**
以强认证运行Hbase RPC，你必须设置hbase.security.authentication为kerberos。这种情况下，你也需将core-site.xml中的hadoop.security.authenrication为kerberos。否则，你将使用HBase强认证而不是底层的HDFS,这将抵消所有好出。
**Kerberos KDC (密钥分发中心)**

###  59.2. 服务器端的安全操作配置###
首先，参考上一小节的安全先决条件并确保底层的HDFS配置是安全的。

将下面的内容加到hbase-site.xml中，集群中每台服务器都要修改。

    <property>
  	 <name>hbase.security.authentication</name>
  	 <value>kerberos</value>
 	</property>
	<property>
  	 <name>hbase.security.authorization</name>
  	 <value>true</value>
	</property>
	<property>
	 <name>hbase.coprocessor.region.classes</name>
  	 <value>org.apache.hadoop.hbase.security.token.TokenProvider</value>
	</property>

部署完成这些配置后，需要重启HBase服务器。

### 59.3. 客户端的安全操作配置 ###
首先参考先决条件并确保你的底层HDFS配置是安全的。

每个客户端的hbase-site.xml中加入如下内容：

	<property>
  	 <name>hbase.security.authentication</name>
  	 <value>kerberos</value>
	</property>

在与hbase集群通信可能之前，客户端环境必须从KDC或通过kinit命令的keytab登陆到Kerberos。

注意， 客户端和服务端文件中的hbase.security.authentication如果不匹配， 客户端将无法与集群进行通信。

一旦HBase配置好安全的RPC，就可能选择性地配置加密通信。 要这样做，在每个客户端hbase-site.xml中加入下面内容：

	<property>
  	 <name>hbase.rpc.protection</name>
  	 <value>privacy</value>
	</property>

这个配置资源也可以每次连接时设置。在提交给表格的配置中提供设置：

    Configuration conf = HBaseConfiguration.create();
	Connection connection = ConnectionFactory.createConnection(conf);
	conf.set("hbase.rpc.protection", "privacy");
	try (Connection connection = ConnectionFactory.createConnection(conf)){
	try (Table table = connection.getTable(tableName.valueOf(tablename))){
		...do your stuff
		}
	}

### 59.4.客户端安全操作配置--Thrift Gateway ###
为每个Thrift gateway在hbase-site.xml文件中加入下面内容：

    <property>
  	 <name>hbase.thrift.keytab.file</name>
  	 <value>/etc/hbase/conf/hbase.keytab</value>
	</property>
	<property>
  	 <name>hbase.thrift.kerberos.principal</name>
  	 <value>$USER/_HOST@HADOOP.LOCALDOMAIN</value>
  	 <!-- TODO: This may need to be  HTTP/_HOST@<REALM> and _HOST may not work. You may have  to put the concrete full hostname.-->	
	</property>
	 <!-- Add these if you need to configure a different DNS interface from the default -->
	<property>
  	 <name>hbase.thrift.dns.interface</name>
  	 <value>default</value>
	</property>
	<property>
  	 <name>hbase.thrift.dns.nameserver</name>
  	 <value>default</value>
	</property>

for $USER and $KEYTAB 替代相应的证书和密钥表。

为了使用Thrift API与Hbase互动， 有必要在hbase.thrift.kerberos.principal中加入**acl**表。例如，  to give the Thrift API principal, thrift_server, administrative access, a command such as this one will suffice:

    grant 'thrift_server', 'RWCA'

Thrift gateway将使用提供的凭据认证HBase。Thrift gateway本身不会进行认证。所有联入Thrift gateway的客户端将使用Thrift gateway的凭据并具有其特权。

### 59.5.Thrift Gateway配置：代替客户端进行身份验证  ###

59.4小节描述了如何配置来验证Thrift客户端对HBase固定使用者的身份。作为一种替换， 也可以配置Thrift gateway代替客户端来进行身份认证，使用代理用户来连接Hbase。

To enable it, do the following.

1. 确保Thrift运行在安全模式中， 通过按照59.4小节中描述的步骤。
2. 确保HBase允许代理用户，将在59.8小节中介绍。
3. 集群中每台运行Thrift gateway的节点的hbase-site.xml中，配置hbase.thrift.security.qop参数为以下三个值中的一个：	
 - privacy -认证，完整性和保密性检查。
 - integrity -认证和完整性检查。
 - authentication - 仅认证检查。
4. 重启Thrift gateway使改变生效。如果一个节点在运行Thrift, **jps** 命令的结果将列出 **ThriftServer** 进程。使用 ***bin/hbase-daemon.sh stop thrift*** ,来停止节点上的Thrift。而使用***bin/hbase-daemon.sh start thrift***来启动Thrift服务。

### 59.6. doAs功能的Thrift gateway配置 ###
59.5小节介绍了如何配置Thrift gateway来替代客户端进行HBase认证，使用代理用户访问HBase。这种方法的限制是在客户端被初始化。这种方法的缺点是在客户端通过某组特定的凭证初始化之后，通话过程中就无法改变这些凭证。doAs特征提供了一种灵活的方式，使用同一客户端可以模拟多个原则。This feature was implemented in HBASE-12640 for Thrift 1, but is currently not available for Thrift 2.

To enable the doAs feature, add the following to the hbase-site.xml file for every Thrift gateway:

    <property>
  	 <name>hbase.regionserver.thrift.http</name>
  	 <value>true</value>
	</property>
	<property>
  	 <name>hbase.thrift.support.proxyuser</name>
  	 <value>true/value>	
	</property>

为了使代理用户使用doAs模拟，将下面内容加入到hbase-site.xml(每个hbase节点)：
    
    <property>
  	 <name>hadoop.security.authorization</name>
  	 <value>true</value>
	</property>
	<property>
  	 <name>hadoop.proxyuser.$USER.groups</name>
  	 <value>$GROUPS</value>
	</property>
	<property>
  	 <name>hadoop.proxyuser.$USER.hosts</name>
  	 <value>$GROUPS</value>
	</property>

### 59.7 安全操作的客户端配置 - REST Gateway ###

Add the following to the hbase-site.xml file for every REST gateway:

    <property>
  	 <name>hbase.rest.keytab.file</name>
  	 <value>$KEYTAB</value>
	</property>
	<property>
  	 <name>hbase.rest.kerberos.principal</name>
  	 <value>$USER/_HOST@HADOOP.LOCALDOMAIN</value>
	</property>

替换相应的凭证和键表 for $USER and $KEYTAB 。

REST gateway将使用提供凭证认证Hbase。

为了使用REST API principal与HBase交互，有必要将hbase.rest.kerberos.principal加入到acl表中。例如，to give the REST API principal, rest_server, administrative access, a command such as this one will suffice:

    grant 'rest_server', 'RWCA'

For more information about ACLs, please see the Access Control Labels (ACLs) section

HBase REST gateway支持客户使用SPNEGO HTTP authentication 访问gateway.To enable REST gateway Kerberos authentication for client access, add the following to the hbase-site.xml file for every REST gateway.

    <property>
 	 <name>hbase.rest.support.proxyuser</name>
  	 <value>true</value>
	</property>
	<property>
  	 <name>hbase.rest.authentication.type</name>
  	 <value>kerberos</value>
	</property>
	<property>
  	 <name>hbase.rest.authentication.kerberos.principal</name>
  	 <value>HTTP/_HOST@HADOOP.LOCALDOMAIN</value>
  	</property>
	<property>
  	 <name>hbase.rest.authentication.kerberos.keytab</name>
  	 <value>$KEYTAB</value>
	</property>
	<!-- Add these if you need to configure a different DNS interface from the default -->
	<property>
  	 <name>hbase.rest.dns.interface</name>
  	 <value>default</value>
	</property>
	<property>
  	 <name>hbase.rest.dns.nameserver</name>
  	 <value>default</value>
	</property>

替换键表 for HTTP for $KEYTAB.

HBase REST gateway 支持不同‘hbase.rest.quthentication.type’:simple, kerberos.可实现一个自定义认证通过实现Hadoop AuthenticationHandler， 然后指定完整的类名作为‘hbase.rest.authentication.type’的值。

### 59.8. REST Gateway 模拟配置 ###
默认情况下，REST GateWay不支持模拟。它代表客户端访问HBase，使用之前配置的用户。对HBase server， 所有请求来自REST gateway使用者。真实使用者是未知的。可以将模拟支持打开。模拟情况下，REST gateway用户是代理用户。HBase服务器知道每个请求的真实使用者。所有它可以使用适当的认证。

要打开REST gateway模拟，需要我们配置HBase服务器（masters 和region servers）使其准许代理用户；配置REST gateway来打开模拟。

To allow proxy users, add the following to the hbase-site.xml file for every HBase server:

    <property>
  	 <name>hadoop.security.authorization</name>
  	 <value>true</value>
	</property>
	<property>
  	 <name>hadoop.proxyuser.$USER.groups</name>
  	 <value>$GROUPS</value>
	</property>
	<property>
  	 <name>hadoop.proxyuser.$USER.hosts</name>
  	 <value>$GROUPS</value>
	</property>

Substitute the REST gateway proxy user for $USER, and the allowed group list for $GROUPS.

To enable REST gateway impersonation, add the following to the hbase-site.xml file for every REST gateway.

    <property>
  	 <name>hbase.rest.authentication.type</name>
  	 <value>kerberos</value>
	</property>
	<property>
   	 <name>hbase.rest.authentication.kerberos.principal</name>
  	 <value>HTTP/_HOST@HADOOP.LOCALDOMAIN</value>
	</property>	
	<property>
  	 <name>hbase.rest.authentication.kerberos.keytab</name>
  	 <value>$KEYTAB</value>
	</property>

Substitute the keytab for HTTP for $KEYTAB.

## 60. Simple User Access to Apache HBase ##
0.92之后发布的版本支持可选的SASL客户端认证。

这里介绍如何设置HBase和客户端实现简单用户访问HBase资源。
### 60.1.简单访问和安全访问 ###
下面章节介绍如何设置简单用户访问。简单用户访问不是一种操作HBase的安全方法。这种方法是用来阻止用户错误操作。它可以用来模拟访问控制使用在一个开发系统而无需设置Kerberos。

这种方法不是用来防止恶意或黑客攻击。要使HBase避开这些攻击，你必须配置HBase安全操作。

### 60.2. 先决条件 ###
无

### 60.3. Server-side Configuration for Simple User Access Operation### 
Add the following to the hbase-site.xml file on every server machine in the cluster:

    <property>
  	 <name>hbase.security.authentication</name>
  	 <value>simple</value>
	</property>
	<property>
  	 <name>hbase.security.authorization</name>
  	 <value>true</value>
	</property>
	<property>
  	 <name>hbase.coprocessor.master.classes</name>
     <value>org.apache.hadoop.hbase.security.access.AccessController</value>
	</property>
	<property>
     <name>hbase.coprocessor.region.classes</name>
  	 <value>org.apache.hadoop.hbase.security.access.AccessController</value>
	</property>
	<property>
  	 <name>hbase.coprocessor.regionserver.classes</name>
  	 <value>org.apache.hadoop.hbase.security.access.AccessController</value>
	</property>

For 0.94, add the following to the hbase-site.xml file on every server machine in the cluster:

    <property>
  	 <name>hbase.rpc.engine</name>
  	 <value>org.apache.hadoop.hbase.ipc.SecureRpcEngine</value>
	</property>
	<property>
  	 <name>hbase.coprocessor.master.classes</name>
  	 <value>org.apache.hadoop.hbase.security.access.AccessController</value>
	</property>
	<property>
  	 <name>hbase.coprocessor.region.classes</name>
  	 <value>org.apache.hadoop.hbase.security.access.AccessController</value>
	</property>

重启HBase服务使这些变化生效。

### 60.4.简单用户访问操作的客户端配置 ###
Add the following to the hbase-site.xml file on every client:

    <property>
  	 <name>hbase.security.authentication</name>
  	 <value>simple</value>
	</property>

For 0.94, add the following to the hbase-site.xml file on every server machine in the cluster:
	
    <property>
  	 <name>hbase.rpc.engine</name>
  	 <value>org.apache.hadoop.hbase.ipc.SecureRpcEngine</value>
	</property>
	
注意如果客户端和服务端的hbase.security.authentication如果不一致，客户端可能无法与集群通信。

#### 60.4.1.简单用户访问操作的客户端配置 -Thrift Gateway ####
Thrift gateway将需要访问。例如，给Thrift API 用户，thrift_server, 管理访问，一个下面这样的命令：

    grant 'thrift_server', 'RWCA'

The Thrift gateway will authenticate with HBase using the supplied credential. No authentication will be performed by the Thrift gateway itself. All client access via the Thrift gateway will use the Thrift gateway’s credential and have its privilege.

#### 60.4.2.简单用户访问操作的客户端配置- REST Gateway####
The REST gateway will authenticate with HBase using the supplied credential. No authentication will be performed by the REST gateway itself. All client access via the REST gateway will use the REST gateway’s credential and have its privilege.

The REST gateway user will need access. For example, to give the REST API user, rest_server, administrative access, a command such as this one will suffice:
	
    grant 'rest_server', 'RWCA'
    
客户端通过REST gateway以一种通过SPNEGO HTTP认证方式认证HBase集群。这是未来的工作。

## 61.HDFS和 ZooKeeper 的安全访问 ##
安全的HBase应满足安全ZooKeeper和HDFS以使用户无法访问或修改元数据或HBase下的数据。HBase使用HDFS来保存数据文件、WALs（write ahead logs）以及其他数据。Hbase使用ZooKeeper来存储某些操作的元数据。

### 61.1. ZooKeeper数据安全性 ###
ZooKeeper具有可插入的认证机制使客户端访问Zookeeper可以使用不同的方法。其甚至同时允许认证和非认真客户端。通过提供访问控制表可以限制znode的访问。ACL(访问控制表)包含两种内容， 认真方法和原则。

HBase服务通过SASL和kerberos认证到Zookeeper。HBase设置znode的访问控制表以使只有HBase用户和配置的HBase超级用户可以访问和修改数据。在Zookeeper被用来服务发现和客户状态分享的情况下， HBase创建的znodes也将允许任何用户访问，并读取znodes（不管是否认证）,但只有HBase用户可以进行修改。

### 61.2. 文件系统（HDFS）数据安全性###
所有被管理的数据被保存在文件系统的根目录下（hbase.rootdir）。对文件系统中的数据和WAL文件的访问应该是受限制的这样用户无法越过Hbase这一层,从文件系统中查看底层的数据文件。HBase假定文件系统（HDFS或其他）进行权限分级。如果没有文件系统没有提供充足的保护（授权和认证），Hbase等级授权就没有意义了因为用户总是能从文件系统访问数据。

HBase对根目录使用类似posix的权限 700（rwx------）这意味着只有HBase用户可以读写文件系统中的文件。默认设置可以通过配置hbase-site.xml中的hbase.rootdir.perms修改。需要重启活跃的主节点使权限修改生效。对于1.2.0之前的版本，你可以检查是否提交HBASE-13780， 如果没有，如果需要的话，你可以手动设置根目录权限。使用HDFS，下面这样的命令：

    sudo -u hdfs hadoop fs -chmod 700 /hbase

上面命令中如果你使用不同的hbase.rootdir你需要修改/hbase

在安全模式中，要配置SecureBulkLoadEndpoint 并用于正确处理Mr job给Hbase服务和HBase用户创建的用户文件。分布式文件系统中用于批量加载的临时目录（**hbase.bulkload.staging.dir**, 默认为 /tmp/hbase-staging）应该具有（mode 711, or rwx--x--x）,这样用户才能访问父目录下创建的临时目录，但却不能做任何操作。

## 62. 数据访问安全性##
在配置过HBase客户端与服务进程、网关之间的安全性之后，需要考虑下数据本身的安全性。HBase提供了一些方法确保数据安全：

- 角色基础上的访问控制，用户或用户组可以使用熟悉的角色读写一个已知的HBase资源或执行一个协处理器的端点
- 可见性标签，允许您标记cells和控制对标记cells的访问,进一步限制谁可以读写你数据的某些子集，可见性标签以tag形式存储。
- 底层文件系统的空闲数据的透明性加密，Hfiles和wal。这将保护你底层空闲数据以防被具有底层文件系统访问权限的攻击者攻击，而不需要修改客户端的实现，也可防止数据从正确配置的磁盘中泄露，这对法律和规则的一致性很重要。

下面将讨论在不降低性能情况下，服务器端配置、管理以及实现的一些细节。最后会给出一个安全配置的例子，包含所有这些特性，就像它们可能在现实世界中那样。


***Procedure: Basic Server-Side Configuration***

1. 通过设置 hbase-site.xml中的hfile.format.version为3使HFile v3生效。1.0以后的HBase版本中这属于默认配置
	
	<property>
  	 <name>hfile.format.version</name>
  	 <value>3</value>
	</property>

2. 打开RPC和Zookeeper的SASL和kerberos认证。

### 62.1. tags ###
tags是HFile v3的一个特征。标签是从键中分离出来的cell中部分元数据的一部分。标签是一个实现细节，提供了一个基础的其他安全相关的功能，如细胞水平的ACL和可见性标签。标签保存在HFiles中。未来有可能标签被用来实现其他HBase功能。为了使用它们启动的安全功能，你不需要了解太多关于标签。
#### 62.1.1. 实现细节 ####
每个cell可以有0或多个标签，每个标签有一个类型和实际标签字节数组

就像rowkey，column family， qualifier和values可以被编码，标签也能被编码。可以在列族的水平上启用或禁用标签编码，默认情况下是打开的。使用HColumnDescriptor#setCompressionTags(boolean compressTags)方法管理列族的编码设置。为使标签编码生效，需要为列族打开DataBlockEncoder 。

使用wal加密时不支持标签压缩.

###62.2. 访问控制标签（acls）###
####62.2.1.它是怎样工作的####
Hbase中的ACL是基于组中或组外的成员，给定组可访问给定资源，其是由协处理器AccessController实现。

HBase不维持私人组映射，但依靠一个Hadoop组映射，目录中实体之间的映射如LDAP或Active Directory和HBase用户。Any supported Hadoop group mapper will work. 然后用户授予特定的权限（读、写、执行、创建、管理）和资源（全局命名空间、表、细胞或端点）。

> 启动Kerberos和访问控制，客户端访问HBase是认证过的， 用户数据是私有的，除非访问被明确准许。

HBase比起关系型数据库具有一个简单的安全模型，特别是在客户操作方面。更新一个记录和插入一条记录之间基本没有区别，例如，当在一个Put中两个都崩溃。

**理解访问等级**

HBase访问级别是相互独立的，在一个给定权限内允许不同类型的操作。

- Read(R) 在给定权限内读数据
- Write（W）在给定权限内写数据
- Excute(X)在给定权限内执行协处理器端点
- Create（C）在给定权限内创建或删除表
- Admin(A)在给定权限内，执行集群操作，如平衡集群或分配区域

可能的权限：

- 超级用户-可以在HBase中对任意资源执行所有操作。在集群中启动HBase的是一个超级用户，as are any principals assigned to the configuration property hbase.superuser in hbase-site.xml on the HMaster.
- 全局-在全局范围内授予的权限，允许管理员在集群的所有表上进行操作。
- 命名空间-在命名空间内授予权限，可以操作所在空间中的所有表
- 表-表范围内的权限，只可以修改对应表的数据或元数据
- 列族-列族范围内的权限，对列族内的cell进行修改
- cell-cell范围内的权限，只允许对cell坐标内的（key， value， 时间戳）进行修改。这允许随着数据进行策略演进。

要改变特定cell的ACL,写一个更新的ACLs代替原来的精确坐标。

如果你有多个版本的表格，并想给每个可见的版本更新ACLs，需要写一个新的cells为所有可见的版本。应用完全控制策略演进。

上述规则的异常是追加和增量处理。增加和追加可以在操作中带着ACL。如果某个操作中包含访问控制，那么增加与追加的结果中也将被应用相应的访问控制。另外，你正在增加或补充的已存在cell的ACL会被保存下来。

访问等级和范围的组合创建了一个可能访问级别的矩阵，这个可以被授予给用户。在生产环境中，根据完成一个特定的工作需要什么来确定访问等级是很有用的。下面的表格介绍了对某些共性HBase用户的适当的访问级别。下面给出了一些常见类型的HBase用户适当的访问级别。重要的是不要给某个用户他完成某项工作所需权限之外的权限。

- 超级用户- 在生产系统中， 只有HBase用户具有超级用户访问权限。在开发环境中，管理者可能需要超级用户访问权限用来快速控制和管理集群。当然，这类管理者通常应该是 一个全局管理者而不是一个超级用户。
- 全局管理者- 全局管理者可以执行任务并访问HBase中的表格。在典型的生产环境中，管理者不应该对表中数据具有读写权限。
- 一个具有全局权限的全局管理者能够在集群范围内对集群进行操作，比如负载均衡，部署或反部署区域，或调用显式的主压缩。这是一个操作角色。
- 具有创造权限的全局管理者能够在Hbase中建立或删除表格。这是个DBA角色类型

生产环境中，很有可能不同用户只有管理或创建权限中的一个。

> 当前的实现中，一个具有管理权限的全局管理者能够授权自己读写表的权限，并获取对表的数据的访问。出于这个原因，只能将全局管理权限给那些真正需要它们的受信任用户。

> 同样要知道具有create权限的全局管理者可以在ACL表上执行Put操作，可模拟一个grant授予或revoke撤销操作，并规避全局管理者的权限检查。

> 出于这些问题，对待全局管理者要格外小心。

- 命名空间管理- 一个具有create权限的命名空间管理者能够建立或删除那个空间的表 ，获取和恢复快照。具有管理权限的命名空间管理者能够对那个空间的表执行如splits或主压缩之类的操作
- 表管理者-表管理者只能对表执行管理操作。具有create权限的表管理者能够创建表的快照或从快照恢复表。具有admin权限的表管理者能够对那张表执行splits或主压缩之类的操作
- 用户-用户可以读或写数据，或读写数据。如果用户具有执行权限，他可以执行协处理器终点（excute coprocessor endpoints）。
 
 表1.真实世界访问等级表,见最后。

	<table class="table talbe-bordered table-striped table-condensed">
	 <caption class="table">表1.真实世界访问等级表
	 </caption>
 	 <tr>
   	   <td>任务名称</td>
   	   <td>范围	  </td>
   	   <td>权限    </td>
   	   <td>描述    </td>
 	 </tr>
 	 <tr>
   	   <td>高级管理者</td>
   	   <td>全局</td>
   	   <td>访问、创建</td>
   	   <td>管理整个集群并允许中级管理者访问</td>
 	 </tr>
 	 <tr>
   	   <td>中级管理者</td>
   	   <td>全局</td>
   	   <td>创建</td>
   	   <td>创建表格允许表哥管理者访问</td>
 	 </tr>
 	 <tr>
           <td>表格管理者</td>
           <td>表格</td>
   	   <td>访问</td>
   	   <td>使用操作维护表格</td>	
 	 </tr>
 	 <tr>
   	   <td>数据分析</td>
   	   <td>表格</td>
   	   <td>读</td>
   	   <td>利用HBase数据创建报告</td>
 	 </tr>
 	 <tr>
   	   <td>网页应用</td>
   	   <td>表格</td>
    	   <td>读写</td>
   	   <td>向HBase中数据并使用数据实现操作</td>
 	 </tr>
 


 *ACL 矩阵*

For more details on how ACLs map to specific HBase operations and tasks, see appendix acl matrix.

实现细节

Cell级的ACLs是使用标签实现的。要使用cell级ACLs，必须使用HFile v3和高于0.98版的HBase。

1. HBase创建的文件属于运行HBase进程的操作系统用户。与HBase文件交互，你应该使用API或大容量设备。

2. HBase中没有模型的角色。相反，组名可以被授予权限。这允许通过组成员实现外部的角色模型。组是在HBase外部通过HBase组映射服务建立和维护的。

服务器端配置

1. As a prerequisite, perform the steps in Procedure: Basic Server-Side Configuration.
2. 安装并配置访问控制协处理器，通过在hbase-site.xml中设置下面的属性。这些属性需要一个类的列表。Optionally, you can enable transport security, by setting hbase.rpc.protection to privacy. This requires HBase 0.98.4 or newer.

	
	<property>
  	 <name>hbase.coprocessor.region.classes</name>
     <value>org.apache.hadoop.hbase.security.access.AccessController, org.apache.hadoop.hbase.security.token.TokenProvider</value>
	</property>
	<property>
  	 <name>hbase.coprocessor.master.classes</name>
  	 <value>org.apache.hadoop.hbase.security.access.AccessController</value>
	</property>
	<property>
  	 <name>hbase.coprocessor.regionserver.classes</name>
  	 <value>org.apache.hadoop.hbase.security.access.AccessController</value>
	</property>
	<property>
  	 <name>hbase.security.exec.permission.checks</name>
  	 <value>true</value>
	</property>

	
3. 在Hadoop的namenode的core-site.xml中设置hadoop group mapper。 这是个Hadoop文件， 而不是HBase文件。根据你的页面自定义设置它，下面只是个例子。

	<property>
  	 <name>hadoop.security.group.mapping</name>
  	 <value>org.apache.hadoop.security.LdapGroupsMapping</value>
	</property>

	<property>
  	 <name>hadoop.security.group.mapping.ldap.url</name>
  	 <value>ldap://server</value>
	</property>

 	<property>
  	 <name>hadoop.security.group.mapping.ldap.bind.user</name>
  	 <value>Administrator@example-ad.local</value>
	</property>

	<property>
  	 <name>hadoop.security.group.mapping.ldap.bind.password</name>
  	 <value>****</value>
	</property>

	<property>
  	 <name>hadoop.security.group.mapping.ldap.base</name>
  	 <value>dc=example-ad,dc=local</value>
	</property>

	<property>
  	 <name>hadoop.security.group.mapping.ldap.search.filter.user</name>
  	 <value>(&amp;(objectClass=user)(sAMAccountName={0}))</value>
	</property>

	<property>
  	 <name>hadoop.security.group.mapping.ldap.search.filter.group</name>
  	 <value>(objectClass=group)</value>
	</property>

	<property>
  	 <name>hadoop.security.group.mapping.ldap.search.attr.member</name>
  	 <value>member</value>
	</property>

	<property>
  	 <name>hadoop.security.group.mapping.ldap.search.attr.group.name</name>
  	 <value>cn</value>
	</property>

4. 可选地，使早期的评估策略。0.98之前，如果用户没有访问一个column family，或至少是一个column qualifier，会抛出AccessDeniedException 。0.98之后去除了这个exception，为了准许cell-level额外
批准。要恢复这个早期的行为，可以在hbase-site.xml中配置 hbase.security.access.early_out为真。在HBase0.98.6中这个默认为真。

5. 在集群中分发配置并重启以使其生效。
6. 要验证你的配置，就登陆到HBase shell中使用命令*whoami*来获取当前用户的组别。例如， 下面例子报告了该用户为服务组的成员。

管理

管理任务可以通过shell或API完成。

1\. 用户和组管理
在你的目录中，用户和组在Hbase外被维护。
2\. 授予访问命名空间、表、列族或单元格的权限。授权的表达有几种不同的语句。下面是最常见的，带有表名和column family可选：
	
	grant 'user', 'RWXCA', 'TABLE', 'CF', 'CQ'

用户和组被以同样的方式授权访问， 但是组会以@为前缀。同样，表和命名空间也是这样指定的，但命名空间以@开头。正如这个例子中，也可以在一个单一语句中对同一资源授予多个权限。ACLs中第一子条款和第二子条款用户指定相应资源。

ACL间隔尺度和求值顺序

ACLs求值从最小间隔到最大间隔，当到达一个ACL的授予权限时，求值结束。This means that cell ACLs do not override ACLs at less granularity.

***Example 20. HBase Shell***
	
	#Global:
		hbase> grant '@admins', 'RWXCA'

	#Namespace:
		hbase> grant 'service', 'RWXCA', '@test-NS'
	#Table:
		hbase> grant 'service', 'RWXCA', 'user'
	#Column Family:
		hbase> grant '@developers', 'RW', 'user', 'i'
	#Column Qualifier:
		hbase> grant 'service, 'RW', 'user', 'i', 'foo'
	#Cell:
		#授予cell的ACLs使用下面的语句：
		
		grant <table>, \
  		 { '<user-or-group>' => \
    	 '<permissions>', ... }, \
  		 { <scanner-specification> }

	#<user-or-group>是用户名或组名，一个组名以@为前缀。
	#<权限>是一个包含任何或全部“RWXCA”的字符串。尽管只有R和W在cell范围是有意义的。
        #<scanner-specification扫描规范>是在使用‘scan’shell时的扫描规范语句和习惯。下面的HBase shell命令是扫描规范语句的例子。
	
	hbase> help "scan"
        这个例子给予“测试用户”读的权限，“开发”组读写权限，在cells中的'pii'列匹配过滤。
	hbase> grant 'user', \
		{ '@developers' => 'RW', 'testuser' => 'R' }, \
  		{ COLUMNS => 'pii', FILTER => "(PrefixFilter ('test'))" }	

	这条shell将用某个移植的标准来执行扫描，使用新的ACLs重写发现的cells，并将它们存回它们所在的坐标中。

***Example21.API***
下面是一个如何进行表级别的授予访问的例子。

	public static void grantOnTable(final HBaseTestingUtility util, final String user,
    	final TableName table, final byte[] family, final byte[] qualifier,
    	final Permission.Action... actions) throws Exception {
      SecureTestUtil.updateACLs(util, new Callable<Void>() {
    	@Override
    	public Void call() throws Exception {
      	  Configuration conf = HBaseConfiguration.create();
      	  Connection connection = ConnectionFactory.createConnection(conf);
      	  try (Connection connection = ConnectionFactory.createConnection(conf)) {
        	try (Table table = connection.getTable(TableName.valueOf(tablename)) {
          	  AccessControlLists.ACL_TABLE_NAME);
          	  try {
            	BlockingRpcChannel service = acl.coprocessorService(HConstants.EMPTY_START_ROW);
            	AccessControlService.BlockingInterface protocol =
                AccessControlService.newBlockingStub(service);
            	ProtobufUtil.grant(protocol, user, table, family, qualifier, actions);
          	  } finally {
            	acl.close();
          	}
          	return null;
          }
        }
       }
      }
     }


在cell级别授予权限，你可以使用Mutation.setACL方法：

	Mutation.setACL(String user, Permission perms)
	Mutation.setACL(Map<String, Permission> perms)

具体而言，下面例子给一个叫做user1的用户提供了包含在特定Put操作的cells读权限

	put.setACL(“user1”, new Permission(Permission.Action.READ))
	
 3\. 从命名空间（namespace）、表（table）、Column Family和Cell中撤销访问控制
 
 撤销命令、API和授予命令、API是一堆双胞胎，语法极为相近。唯一例外是不能从细胞级撤回权限。只能撤回之前授予的访问权限。撤销语句与资源的显式拒绝不是同一个东西。

***Example22. 撤销表的访问***

	public static void revokeFromTable(final HBaseTestingUtility util, final String user,
    	final TableName table, final byte[] family, final byte[] qualifier,
    	final Permission.Action... actions) throws Exception {
  	  SecureTestUtil.updateACLs(util, new Callable<Void>() {
    	@Override
    	public Void call() throws Exception {
      	  Configuration conf = HBaseConfiguration.create();
      	  Connection connection = ConnectionFactory.createConnection(conf);
      	  Table acl = connection.getTable(util.getConfiguration(), AccessControlLists.ACL_TABLE_NAME);
      	  try {
        	BlockingRpcChannel service = acl.coprocessorService(HConstants.EMPTY_START_ROW);
        	AccessControlService.BlockingInterface protocol =
            AccessControlService.newBlockingStub(service);
        	ProtobufUtil.revoke(protocol, user, table, family, qualifier, actions);
      	  } finally {
        	acl.close();
      	  }
      	  return null;
   	     }
  	   });
	}
	
4\. 显示用户的有效权限

***Examaple 23. HBase Shell***
	
	hbase> user_permission 'user'

	hbase> user_permission '.*'

	hbase> user_permission JAVA_REGEX

***Example 24. API***

	public static void verifyAllowed(User user, AccessTestAction action, int count) throws Exception {
  	  try {
    	Object obj = user.runAs(action);
    	if (obj != null && obj instanceof List&lt;?&gt;) {
      	  List&lt;?&gt; results = (List&lt;?&gt;) obj;
      	if (results != null && results.isEmpty()) {
        	fail("Empty non null results from action for user '" ` user.getShortName() ` "'");
      	}
      	assertEquals(count, results.size());
       }
  	  } catch (AccessDeniedException ade) {
    	fail("Expected action to pass for user '" ` user.getShortName() ` "' but was denied");
  	 }
	}

### 62.3 可见性标签 ###

可见性标签控件可用于仅允许具有给定标签的用户或负责人读或者访问那个标签的cells。例如， 给一个cell贴一个top-secret的标签， 只授予这个标签的访问权限给manage群组。可见标签是使用tags实现的，这是HFile v3的特性，使你可以在每个cell的基础上存储元数据。标签是一串字符串，标签可以用逻辑操作符组合起来（&，|，或！），使用分组的圆括号。Hbase不做任何验证表达是否超越基本的合法性。可见性标签对自己没有任何意义，并可以用于表示灵敏度级别、权限级别或其他任意的语义。

如果用户的标签与cell的标签不匹配， 则用户被拒绝访问cell。

在0.98.0之后的版本后，可见性标签和表达支持UTF-8编码，当使用addLabels方法（org.apache.hadoop.hbase.security.visibility.VisibilityClient class）创建标签并通过Scan或Get传递标签获取授权时，标签能够包含UTF-8字符以及常用于可见性标签的逻辑操作符，普通的java符号不需要特殊的方法。但是，当你通过一个Mutation传递一个CellVisibility表达时，如果使用UTF-8字符或逻辑操作时，你必须使用CellVisibility.quote()方法来封装表达。See TestExpressionParser and the source file hbase-client/src/test/java/org/apache/hadoop/hbase/client/TestScan.java.

可见性标签可结合ACL使用。

表2. 可见性标签例子见后

<table class="table table-borded table-striped ">
 <caption class="table">表2.可见性表达例子
  </caption>
 <tr>
   <td>表达   </td>
   <td>解释   </td>
 </tr>
 <tr>
   <td>fulltime </td>
   <td>允许具有fulltime标签的用户访问</td>
 </tr> 
 <tr>
   <td>!public   </td>
   <td>允许不具有public标签的用户访问</td>
 </tr>
 <tr>
   <td>( secret | topsecret ) & !probationary</td>
   <td>允许具有secret或topsecret但不具有probationary标签的用户访问</td>
 </tr>

#### 62.3.1 服务端配置 ####

1\. As a prerequisite, perform the steps in Procedure: Basic Server-Side Configuration.

2\. 安装配置VisibilityController 协处理器，在hbase-site.xml中配置如下属性.These properties take a list of class names.

	<property>
  	 <name>hbase.coprocessor.region.classes</name>
  	 <value>org.apache.hadoop.hbase.security.visibility.VisibilityController</value>
	</property>
	<property>
  	 <name>hbase.coprocessor.master.classes</name>
  	 <value>org.apache.hadoop.hbase.security.visibility.VisibilityController</value>
	</property>
	
3\. 调整配置

默认情况下，用户可以给cells添加任意标签，包括与他们无关的标签，这意味着用户可以对它无法读取的数据进行Put操作。例如，用户可以给一个cell使用(假定)'topsecret'标签，即使这个用户与这个标签无关无关。如果你只想用户只能给cell添加他们有关的标签，设置hbase.security.visibility.mutations.checkauths这个属性为真，这样mutation将失效如果用户使用与他无关的标签。

4\. Distribute your configuration and restart your cluster for changes to take effect.

#### 62.3.2. Administration ####

Administration tasks可以使用HBase shell 或java api，对定义可见性标签表并关联用户来说，使用Shell简单点。

1\. 定义可见性标签表

***Example 25.Hbase shell***

	hbase> add_labels [ 'admin', 'service', 'developer', 'test' ]

***Example 26.Java API***

	public static void addLabels() throws Exception {
  	  PrivilegedExceptionAction<VisibilityLabelsResponse> action = new PrivilegedExceptionAction<VisibilityLabelsResponse>() {
    	public VisibilityLabelsResponse run() throws Exception {
      	  String[] labels = { SECRET, TOPSECRET, CONFIDENTIAL, PUBLIC, PRIVATE, COPYRIGHT, ACCENT,
          UNICODE_VIS_TAG, UC1, UC2 };
      	  try {
        	VisibilityClient.addLabels(conf, labels);
      	  } catch (Throwable t) {
        	throw new IOException(t);
          }
      	  return null;
    	}
  	  };
  	  SUPERUSER.runAs(action);
	}

2\. 将用户与标签联系起来

***Example 27.HBase Shell***

	hbase> set_auths 'service', ['service']
	hbase> set_auths 'testuser', ['test']
    hbase> set_auths 'qa', ['test', 'developer']
    hbase> set_auths '@qagroup', ['test']

***Example 28. Java API***

	public void testSetAndGetUserAuths() throws Throwable {
  	  final String user = "user1";
  	  PrivilegedExceptionAction<Void> action = new PrivilegedExceptionAction<Void>() {
    	public Void run() throws Exception {
      	  String[] auths = { SECRET, CONFIDENTIAL };
      	  try {
        	VisibilityClient.setAuths(conf, auths, user);
      	  } catch (Throwable e) {
      	  }
      	  return null;
    	}
    	...


3\. 清除用户的标签

***Exmaple29. Hbase shell***

	hbase> clear_auths 'service', ['service']
	hbase> clear_auths 'testuser', ['test']
    hbase> clear_auths 'qa', ['test', 'developer']
	hbase> clear_auths '@qagroup', ['test', 'developer']

***Example 30. Java API***

	...
	auths = new String[] { SECRET, PUBLIC, CONFIDENTIAL };
	VisibilityLabelsResponse response = null;
	try {
  	  response = VisibilityClient.clearAuths(conf, auths, user);
	} catch (Throwable e) {
  	  fail("Should not have failed");
  	  ...
	}

4\.给Cell应用某个标签或表达

标签仅在数据被写入时才被应用。标签与某个给定版本的cell有关。

***Exmaple31. Hbase shell***

	hbase> set_visibility 'user', 'admin|service|developer', { COLUMNS => 'i' }
	hbase> set_visibility 'user', 'admin|service', { COLUMNS => 'pii' }
	hbase> set_visibility 'user', 'test', { COLUMNS => [ 'i', 'pii' ], FILTER => "(PrefixFilter ('test'))" }

***Example 32. Java API***

	static Table createTableAndWriteDataWithLabels(TableName tableName, String... labelExps)
    throws Exception {
  	  Configuration conf = HBaseConfiguration.create();
  	  Connection connection = ConnectionFactory.createConnection(conf);
  	  Table table = NULL;
  	  try {
    	table = TEST_UTIL.createTable(tableName, fam);
    	int i = 1;
    	List<Put> puts = new ArrayList<Put>();
    	for (String labelExp : labelExps) {
      	  Put put = new Put(Bytes.toBytes("row" + i));
      	  put.add(fam, qual, HConstants.LATEST_TIMESTAMP, value);
      	  put.setCellVisibility(new CellVisibility(labelExp));
      	  puts.add(put);
      	  i++;
    	}
    	table.put(puts);
  	} finally {
    	if (table != null) {
      	  table.flushCommits();
    	}
  	}

#### 62.3.3. 使用标签读取Cells ####

当你提交一个Scan或Get, Hbase使用默认的权限设置来过滤你不能访问的cells，超级管理员可以通过使用HBase Shell命令set_auths给某个用户设置默认的权限或者使用VisibilityClient.setAuths()方法 。

Scan和Get中你可以指定不同的权限，通过在HBase shell中传递AUTHORIZATIONS选项。或者在API中使用setAuthorizations()方法。这个授权将和你默认的设置组成一个额外的过滤器。这将进一步过滤你的结果，而不用给你额外的授权。

***Example 33. HBase Shell***

	hbase> get_auths 'myUser'
	hbase> scan 'table1', AUTHORIZATIONS => ['private']

***Example 34. Java API***
	
	...
	public Void run() throws Exception {
  	  String[] auths1 = { SECRET, CONFIDENTIAL };
  	  GetAuthsResponse authsResponse = null;
  	  try {
    	VisibilityClient.setAuths(conf, auths1, user);
    	try {
      	authsResponse = VisibilityClient.getAuths(conf, user);
    	} catch (Throwable e) {
      	fail("Should not have failed");
    	}
  	  } catch (Throwable e) {
  	  }
  	  List<String> authsList = new ArrayList<String>();
  	  for (ByteString authBS : authsResponse.getAuthList()) {
      	authsList.add(Bytes.toString(authBS.toByteArray()));
  	  }
  	  assertEquals(2, authsList.size());
  	  assertTrue(authsList.contains(SECRET));
  	  assertTrue(authsList.contains(CONFIDENTIAL));
  	  return null;
	}
	...

####62.3.4.实现你自己的可见性标签算法  ####
理解对于一个给定get/scan请求的标签认证是一种可插入算法。

可以指定一个自定义的插件通过使用属性hbase.regionserver.scan.visibility.label.generator.class。第一个扫描标签生成器的输出将变为下一个的输入直到表格结束。

The default implementation, which was implemented in HBASE-12466, loads two plugins, FeedUserAuthScanLabelGenerator and DefinedSetFilterScanLabelGenerator. See Reading Cells with Labels.

#### 62.3.5 复制可见标签为字符串 ####
在上面小节中提到过，VisibilityLabelService接口可以被用来实现一种cells中存储可见性表达的不同方式。具有复制能力的集群也必须复制可见性表达式到对等集群中。如果DefaultVisibilityLabelServiceImpl是作为visibilitylabelservice实现，所有可视化表达都被转为存储在标签表中的对应表达。复制过程中，可见cells也按序实现完整复制。peer集群的可能不具有与可见性标签同样映射顺序的标签表。在这种情况下，复制顺序是没有意义的。如果复制时可见性表达以字符串进行传输可能会更好。将可见表达作为字符串复制到peer集群中，会在实现VisibilityLabelService接口的基础上创建一个RegionServerObserver 配置。下面的配置可以将可见性表达作为字符串复制到peer集群中。
	
	<property>
  	 <name>hbase.coprocessor.regionserver.classes</name>
  	 <value>org.apache.hadoop.hbase.security.visibility.VisibilityController$VisibilityReplication</value>
	</property>

###  62.4.Transparent Encryption of Data At Rest###
Hbase提供了保护数据的机制， in HFiles and the WAL，这两个文件在HDFS或其他文件系统内。双层结构式灵活使用和防止侵入的关键节点。“Transparent”指着在客户端不需要任何改变。当写入数据时，数据就被加密了。当数据被读取时，它会按需解密。

#### 62.4.1 How It Works####

管理员规定了集群的主密钥，这个密钥存储在一个关键节点上，这个节点可以被每个授信的Hbase进程访问，进程包括HMaster、RegionServers、以及工作站上客户端（如Hbase shell）。默认的密码提供者与JAVA KeyStore API以及任何支持他密钥管理系统集成在一起。其他自定义key提供者的实现也是可能的。key检索机制实在hbase-site.xml中配置的，主键可以存储在集群服务器中，被安全KeyStore文件保存，或在外部键服务器上，又或在硬件安全模块中。当需要时，这个主键会通过配置的键提供者被Hbase进程解析。

下一步，每个columnfamily，加密使用可以在架构中被指定，通过创建或修改列描述来包含两个额外的属性：使用加密算法的名字（当前只支持AES）和，可选得，一个被集群主键包裹的数据键。如果不为一个ColumnFamily配置明确的数据键，HBase将为每个Hfile创建随机的数据键。这在安全性地替代方面提供了一个增量的改进。除非你需要提供一个明确的数据key，例如在你需要生成加密的Hfile用来使用某个数据key进行批量引入的例子中，只在ColumnFamily表元数据中指定加密算法，让Hbase按需创建数据键。每个列族键促进低影响增量键的循环并减少关键内容的外部泄露范围。被包裹的数据键被存储在ColumnFamily表元数据中，在列族的每个HFile中，用集群主键加过密。column family被配置加密后，任何新的Hfile将写入时也被加密。要确保所有的Hfile被加密，在启动这个功能后，发动一次主紧缩。
